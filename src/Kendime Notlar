Step 2 :

Making a tree

Şimdi bizden istenen şey şu : Sonraki hamleleri içeren bir tree yapmamız lazım.
Bu ne demektir? Diyelim tic-tac-toe, orada mesela ilk hamle olarak 9 branch çıkar, çünkü 1st oyuncu
9 farklı yere bir şey koyabilir. Her bir daldan yine 8 dal çıkar çünkü 2nd oyuncu 8 farklı yere
bir şey koyabilir.

Bu oyunda aynı böyle ancak daha büyük çaplısı. Şimdi bizim board 6x7 den 42 hamle olasılığı içeriyor.
Hala oyunun kurallarını tam anlamış değilim. Mesela play() fonksiyonu, sanıyorum onunla biraz uğraşmam 
gerek, bir analiz şart.
Nasıl oynandığını çözdükten sonra bir oyun nasıl sub-hamlelere bölünür onu düşünmeliyim.
Yine parça parça. Clone() fonksiyonu olduğunu hatırlıyorum. Tercihim, mesela Oyun initial olarak boş.
O zaman, player1 için 42 (veya en yüksek possible hamle) kadar hesaplayıp bu kadar sayıda clone 
yaratmalıyım yani bir clone dizisi.
Yeri gelmişken demek ki, max. kaç hamle yapabileceğimi gösteren bir fonksiyon tasarlamalıyım.
Daha sonra tekrardan bu clone arrayindeki her bir sub-game için yine aynı şeyi tekrarlamalıyım.
Sanıyorum bu ağaçlar için biraz tree structure larına bakmamda yarar var.

O zaman sırasıyla :

1- play fonksiyonunu ve oyunu iyice araştırmalıyım
2- Maximum kaç hamle yapabildiğime dair bir fonksiyon geliştirmeliyim
3- Tree structure ları araştırmalıyım
4- tree yapmalıyım.



-------------------------
Oyun dusundugum gibi degil. Yani soyle, hakikaten ilk once, column sonuna geliyor. Yani o 
yuzden ilk basta width kadar hamle imkani var.
Yani 7. Ancak ikinci oyuncunun da 7. Aslinda fena degil demek ki bir node en fazla 7 dalli olabilir. 
Cunku hep columnlara koyuyoruz.
Bu arada column diyorum ancak sanki oyun left yonune 90 derece yatirilmis gibi.
Her seyi ona gore hesaplamaliyim.
Guzel o zaman belirledigim ilk maddeyi yaptim

------------------------
nextMove() ile sonraki rounda dair hangi oyuncu ise onun oynayacağı tüüm hamleleri gösterebiliyorum.
Şimdi yapmam gereken şey şu: Bunu ard arda yapmak. Yani mesela o nextMove lardan birini alıp onun
üstüne sonraki oyuncu ile bir daha nextMove yapmam. Bir tür bir recursive kurmam.
Bu recursion da base case, valid move kalıp kalmaması.
Valid move olduğu sürece, nextMove yapmalı, o nextMovedan her biri için tekrardan recursion foksiyonunu
uygulamalı. Şunun gibi :

makeATree (board, playerId)
currentPlayer = playerId
boardList = nextMove(board, currentPlayer)
currentPlayer = otherPlayer
for(int i =0; i<7; i++)
    new Array[7] = makeATree(boardList[i], currentPlayer

return 
------------------------------
Peki yani versiyonunu dusundugum saniyorum komple hamle yapilabilir mi gibi bir fonksiyon yapayim :

booelan nextMovePossible(board)
for int i=0 i<7 i++
    if(!board.isValid(i))
        return false

return true;

O zaman yeni versiyon soyle bir sey oluveriyor. Base case olarak baska hamle var mi yok mu onu cozmek istiyorum. Eger hamle varsa recursion
yoksa zaten fonksyion sahip oldugu veriyi dondurmeli. Ancak recursionu nasil yapabilirim. Ben 7li dongu halinde recursion yapiyorum
Ama bunu nasil yapanilirm. Binary tree yapabilirim hakkaten ama cok sacma olur. 


makeATree(board, playerID)

    currentPlayer = playerID
    boardList = nextMove(board, currentPlayer)`
    if (!moveLeft(board))
        return boardlist
    else
        currentPlayer = otherPlayer
        